
---

# 전체 구조 한눈에 보기

* **Unity → 파이썬 서버로 주기적으로 보내는 정보**

  * 현재 탱크의 위치/방향, 라이다(LiDAR) 감지 점들
* **서버가 하는 일 (순서)**

  1. 목적지까지 갈 길(경로) 계산 (D* Lite)
  2. 전방에 장애물이 급박하면 회피
  3. 경로를 따라 전진·회전 지시 (W/A/S/D 키 형식)
  4. 동시에 포탑(Turret)을 목표로 돌리고, 사격 가능한지 판단 (Q/E/R/F + fire)
  5. 이 둘을 하나의 응답으로 합쳐 Unity에 반환
     이 두 조합을 실제로 합치는 함수가 `_merge_aim_response()` 입니다.

---

# 파일 1) `server_D_1110.py` — “자율주행 + 조준/사격” 서버

## 1. 가장 중요한 합치기 함수: `_merge_aim_response(...)`

* 입력:

  * `cmd_ws`: 전/후진(W/S) 명령
  * `cmd_ad`: 좌/우회전(A/D) 명령
  * `dbg`: 디버그 정보
* 내부에서 현재 프레임의 **포탑 각도(turret.x, turret.y)** 를 읽고, 조준/사격 모듈 `aimer.get_action_dict(tx, ty)` 를 호출해 **포탑 명령과 발사 여부**를 받아옵니다.
* 출력: **이동 + 포탑 + 발사**를 한 번에 담은 JSON
  (`moveWS`, `moveAD`, `turretQE`, `turretRF`, `fire`, `debug`)

즉, 주행(W/A/S/D)과 포탑(Q/E/R/F) 제어를 이 함수가 “합쳐서” 돌려준다고 이해하시면 됩니다.

---

## 2. 전역 “상태 보관함”: `state` 딕셔너리

* 위치/목표/방향 및 장애물·경로·라이다 집계·회피 상태 등을 모두 여기 저장합니다. 예를 들어 회피 유지 종료 시각 `evade_until_ts`, 진행 타이머 `start_time` 같은 값도 포함됩니다.
* JSON을 안전하게 읽는 `safe_get_json()`(에러시 빈 dict 반환)과 각도 정규화 `normalize_angle()` 같은 유틸도 제공합니다.

### 위치/방향 업데이트

* `update_player_position(data)`: 다양한 키 이름을 허용해 `(x,z)` 위치를 찾아 `state["pos"]`에 저장합니다.
* `update_player_direction(data)`: 다양한 키에서 **Unity의 Yaw**(차체 방향)를 읽어, 프로젝트 표준 각도계로 변환해 `state["yaw_deg"]`에 저장합니다. 입력 키 후보를 넉넉히 봅니다.
  변환은 `convert_unity_angle_to_standard(...)` 함수가 담당합니다. (Z축 0° 기준을 쓸지 등 옵션 반영)

---

## 3. 맵/그리드/장애물 처리

* 맵 범위, 그리드 해상도(2m), 안전 버퍼(3m → 그리드 2칸) 같은 핵심 상수들이 상단에 정의되어 있습니다. **이 수치가 경로 품질·안전거리의 기본값**입니다.
* 장애물은 3종류를 합칩니다: **static**(맵 고정), **manual**(테스트용 수동 추가), **dynamic**(라이다로 찍히고 TTL 지나면 자동 삭제). 한 번에 모으는 함수가 `blocked_cells(...)` 입니다.
* Unity에서 `.map` 사각형 데이터를 보내면 `replace_static_from_rects(...)`가 **그리드 칸으로 채워 static_cells**를 갱신합니다. `/update_obstacle`가 비동기로 이 작업을 돌리고 완료 로그도 찍습니다.
* 수동 추가/해제는 `/update_occupancy` 가 담당: 셀 좌표 또는 월드 좌표로 넣으면 **버퍼 반경 포함**해서 막거나 해제합니다. 처리 후 `state["need_replan"]=True`로 **재계획 신호**를 세팅합니다.

---

## 4. 라이다 수신과 “즉시 위험 회피”

* `/info` 호출 때 `lidarPoints`를 순회하여 감지된 점을 **동적 장애물**로 추가(`add_dynamic_world`)하고, 현재 머리방향 대비 전방 부채꼴(±30°)에 몇 개가 있는지 집계합니다. 이 집계는 “급박 회피” 판단에 쓰입니다.
* `/get_action` 흐름에서 **3단계**가 “즉시 위험 회피”: 정면이 막혀 있으면 (1) 오른쪽 뚫렸으면 우회전, (2) 왼쪽만 뚫렸으면 좌회전, (3) 둘 다 막히면 **후진+회전**. 그리고 **회피 유지 타이머**를 걸어 다음 몇 프레임도 회피 동작을 유지합니다.

---

## 5. 경로 계획: D* Lite (동적 장애물에 강함)

* D* Lite는 장애물이 변해도 **전체를 매번 처음부터**가 아니라 **변한 부근만** 갱신해 빠르게 경로를 업데이트하는 알고리즘입니다.
* 핵심 메서드:

  * `step_cost(a,b)`: 대각선 이동이면 √2, 직선이면 1칸 비용. (그리드 해상도 곱)
  * `h(a,b)`: 휴리스틱(목표까지 대략 거리 추정)
  * `compute_shortest_path()`: 오픈리스트에서 꺼내며 g/rhs 값을 갱신해 최단경로 트리를 유지
* `/get_action`의 **5단계**에서 `ensure_path_dstar(now_ts)`를 호출해 현재 위치/목표/장애물 집합을 기준으로 **최적 경로**를 계산하고 `state["path_world"]`에 저장합니다. 경로가 없으면 목표 방향으로만 **회전+전진**하는 안전 동작으로 대체합니다.

---

## 6. 주행 명령 생성 로직 (각도 기반)

* 경로 중 **앞쪽 몇 칸(lookahead)** 지점을 향하도록 목표 각도 `tgt_deg`를 계산 → 현재 차체헤딩 `cur_yaw`와의 차이를 `diff`로 구하고, 크기에 따라 **세 가지 분기**:

  1. |diff| > 45° → **제자리 회전**만
  2. |diff| ≤ 5° → **직진만**
  3. 그 사이 → **전진과 회전**을 섞음 (각도 클수록 회전 비중↑)
     이때 만든 `cmd_ws`(전/후진), `cmd_ad`(좌/우) 명령을 포탑 명령과 합쳐 반환합니다.

* 최종 리턴은 늘 `_merge_aim_response(cmd_ws, cmd_ad, dbg)` 형태입니다. (여기서 포탑·발사가 붙습니다)

---

## 7. 주요 엔드포인트 요약

* `GET /init` : Unity 초기 설정값 제공 (로그 저장, 라이다 저장 등)
* `GET /start` : 경과 타이머 시작(단일 목적지 모드). 목적지는 별도로 `/set_destination` 으로 설정.
* `POST /set_destination` : 목표점(x,z) 설정 → 재계획 플래그 ON
* `POST /clear_destination` : 목표 해제(단일 모드)
* `POST /info` : 위치/방향/라이다 수신 → 동적 장애물/전방 위험 집계 갱신
* `POST /get_action` : **메인 루프** — 도착/회피/경로/주행/포탑까지 처리해 한 번에 답변
* `POST /update_obstacle` : 맵의 정적 장애물(.map) 일괄 갱신 (비동기 처리)
* `POST /update_occupancy` : 테스트용 수동 차단/해제 지원
* `GET /debug_state` : 현재 pos/goal/path/장애물 수/파라미터를 한 번에 확인

---

# 파일 2) `tank_aim_app_1105.py` — “포탑 조준/사격” 모듈

이 클래스는 **포신(총구)을 어디로 향해야 하는지(요/피치)** 와 **지금 쏴도 되는지**를 판단해줍니다. 최종 결과는 `get_action_dict(turret_x, turret_y)` 로 얻습니다.

## 1. 설정값 묶음 (dataclass)

* `AimPaths`, `AimGeom`, `AimLimits`, `AimPhysics`, `AimSlope`, `AimSlew`, `AimFireGate` 등:
  로그 파일 경로, 총열 길이·오프셋, 사거리/피치 제한, 초기 속도/중력, 경사/고저차 보정계수, 빠른 회전 스텝, 발사 허용 오차 등.
  (이 값들은 대부분 환경변수로도 바꿀 수 있게 설계됨)

## 2. 핵심 메서드

### (1) `compute_solution(...)`

* 현재 프레임의 **플레이어/적 위치**와 **현재 포탑 각도**를 로그 파일에서 한 줄 읽어 계산합니다.
* 목표 포탑 각도를 구하는 순서:

  1. **탄도학** 기반 피치 각도 시도 (`_ballistic_pitch_deg`)
  2. 안 되면 **사전 측정 데이터(csv)** 로 보간 (`_angle_from_output_csv`)
  3. 그래도 안 되면 **직선 시선각(los)** 로 대체
* 경사·롤(기울기)·고저차에 따른 **피치 보정**도 반영합니다.
* 최종적으로 **원하는 요/피치(desired_yaw/pitch)** 와 현재 각도의 **오차(yaw_delta/pitch_delta)** 를 돌려줍니다.

> 사거리 바깥이면 “out_of_range”로 실패를 즉시 리턴합니다.

### (2) `compute_turret_weights(current_x, current_y, target_x, target_y)`

* 지금 포탑 각도와 목표 각도의 차이를 비례제어(Kp)로 **명령(Q/E, R/F)과 가중치**로 변환합니다.

  * 수평(Yaw): `Q`(왼), `E`(오른)
  * 수직(Pitch): `R`(올림), `F`(내림)
* “빠른 회전(FAST SLEW)” 옵션이 켜져 있으면 큰 오차일 때 가중치를 더 줘서 빠르게 따라가게 합니다.

### (3) `adaptive_fire_gate(err_x, err_y, R, roll_deg, dy, desired_pitch)`

* 발사 허용 오차(야/피치)를 상황에 따라 **동적으로 넓히거나 좁히는** 로직입니다.

  * 멀리 있거나 크게 기울었을 때 약간 완화
  * 최근 오차 추세가 안정적이면 조금 더 완화
* 결과: **지금 쏴도 되는지(`True/False`)와 허용 오차** 를 돌려줍니다.

### (4) `get_action_dict(turret_x, turret_y)`

* 위 3단계를 합쳐 최종 포탑 제어를 만듭니다.

  * 이동은 서버 쪽에서 하고, 여기선 **포탑 회전(Q/E/R/F)과 발사 여부**를 정합니다.
  * `debug`에 계산 근거(거리 R, 롤각, 보정치 등)를 담아줍니다.
* 거리·탄도·데이터보간 등 결정 과정을 그대로 `note`에 적어줘서, **왜 이 각도가 나왔는지** 추적 가능합니다. (compute_solution의 반환 필드)

### 보조 수식 메서드

* `_ballistic_pitch_deg(...)`: 초기속도·중력·수평거리·고저차로 **피치 각** 해석해 구함. 근의 공식 형태(± 루트) 중 더 낮은 각을 채택.
* `_angle_from_output_csv(...)`: Z(거리)–Angle 테이블에서 보간해 피치 추정. 범위 밖이면 실패.

---

# `/get_action` 한 프레임의 실제 흐름 (필독!)

1. **데이터 업데이트**: 위치/방향/라이다를 `state`에 반영
2. **도착 체크**: 목표까지 2.5m 이내면 정지 + 디버그 사유 “arrived”로 응답
3. **즉시 위험 회피**: 정면이 막히면 회피(우회전/좌회전/후진+회전), 회피 타이머 세팅
4. **회피 유지**: 타이머가 남았으면 전진 0.5 + 회전 1.0 유지
5. **경로 확보**: D* Lite로 경로 생성/업데이트 (변화만 반영)
6. **주행 명령 생성**: 목표 각도와의 차이에 따라 “제자리 회전 / 직진 / 혼합” 결정
7. **포탑/발사 덧붙임**: `_merge_aim_response(...)`가 포탑 조준·발사를 붙여 최종 JSON 반환
   (2~7단계는 코드에 주석으로 단계 표기가 있어 따라 읽기 쉽습니다.)

---

# 키 명령 표 (Unity 쪽에서 보기 쉽게)

* **이동**

  * `moveWS.command` : `"W"`(전진) / `"S"`(후진) / `""`(정지)
  * `moveWS.weight` : 0.0 ~ 1.0 (강도)
  * `moveAD.command` : `"A"`(좌회전) / `"D"`(우회전) / `""`
  * `moveAD.weight` : 0.0 ~ 1.0
* **포탑**

  * `turretQE.command` : `"Q"`(포탑 좌) / `"E"`(포탑 우) / `""`
  * `turretRF.command` : `"R"`(포탑 올림) / `"F"`(포탑 내림) / `""`
* **발사**

  * `fire` : `true`(사격 OK) / `false` (아직 아님)

이 값들은 `_merge_aim_response(...)`에서 **주행(cmd_ws/ad)** 과 **조준/사격(aim)** 을 묶어서 리턴합니다.

---

# 테스트 순서 (로컬용, 아주 간단)

1. 서버 실행

2. 초기화 및 타이머

   * `GET /init` : 초기설정 받기
   * `GET /start` : 경과 타이머 시작 (목표는 따로 set)

3. 목적지 설정

   * `POST /set_destination` with `{"x":120,"z":150}` 등 (문자열 `"120,150"`도 허용)

4. 프레임 루프

   * Unity가 매 프레임 `POST /info`로 위치/라이다 갱신, 이어 `POST /get_action` 으로 명령을 받아 실행합니다. (없으면 회전/정지 같은 안전 동작)

5. 상태 확인

   * `GET /debug_state` 로 현재 경로/장애물/파라미터 확인

---

# 정리 포인트 (비전공자용 핵심 요약)

* `server_D_1110.py`는 **길 찾기(D* Lite) + 자동차 조종(W/A/S/D) + 포탑/사격**을 합쳐 **한 번에** 응답하는 **서버**입니다. 흐름은 “도착 체크 → 위험 회피 → 경로계획 → 주행 → 포탑” 순서로 진행됩니다.
* `tank_aim_app_1105.py`는 **포탑을 얼마나 돌리고 올려야 적을 맞출지**를 계산합니다. 탄도학 → 데이터보간 → 시선각 순으로 시도하고, 지형 기울기/높이차 보정까지 고려합니다. 최종적으로 **Q/E/R/F** 명령과 **발사 여부**를 만들어 줍니다.

